<!DOCTYPE HTML>
<html lang="en" >
    
    <head>
        
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <title>Uniendo los conceptos | Introduction</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 2.6.7">
        
        
        <meta name="HandheldFriendly" content="true"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
        <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">
        
    <link rel="stylesheet" href="../gitbook/style.css">
    
        
        <link rel="stylesheet" href="../gitbook/plugins/gitbook-plugin-katex/katex.min.css">
        
    
        
        <link rel="stylesheet" href="../gitbook/plugins/gitbook-plugin-highlight/website.css">
        
    
        
        <link rel="stylesheet" href="../gitbook/plugins/gitbook-plugin-search/search.css">
        
    
        
        <link rel="stylesheet" href="../gitbook/plugins/gitbook-plugin-fontsettings/website.css">
        
    
    

        
    
    
    <link rel="next" href="../alto-orden/registros.html" />
    
    
    <link rel="prev" href="../alto-orden/entornos-contextuales.html" />
    

        
    </head>
    <body>
        
        
    <div class="book"
        data-level="4.2"
        data-chapter-title="Uniendo los conceptos"
        data-filepath="alto-orden/ejemplos.md"
        data-basepath=".."
        data-revision="Thu Apr 14 2016 14:04:13 GMT-0300 (CLST)"
        data-innerlanguage="">
    

<div class="book-summary">
    <nav role="navigation">
        <ul class="summary">
            
            
            
            

            

            
    
        <li class="chapter " data-level="0" data-path="index.html">
            
                
                    <a href="../index.html">
                
                        <i class="fa fa-check"></i>
                        
                        Introduction
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="1" data-path="intro/index.html">
            
                
                    <a href="../intro/index.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>1.</b>
                        
                        Introducción
                    </a>
            
            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1" data-path="intro/declarativa.html">
            
                
                    <a href="../intro/declarativa.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>1.1.</b>
                        
                        La programación declarativa
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="intro/funcional.html">
            
                
                    <a href="../intro/funcional.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>1.2.</b>
                        
                        Definiendo el paradigma funcional
                    </a>
            
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="2" data-path="invariante/index.html">
            
                
                    <a href="../invariante/index.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>2.</b>
                        
                        Recursión y programación invariante
                    </a>
            
            
            <ul class="articles">
                
    
        <li class="chapter " data-level="2.1" data-path="invariante/fundamentos.html">
            
                
                    <a href="../invariante/fundamentos.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>2.1.</b>
                        
                        Programación invariante: fundamentos
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="2.2" data-path="invariante/invariante-real.html">
            
                
                    <a href="../invariante/invariante-real.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>2.2.</b>
                        
                        Programación invariante en el mundo real
                    </a>
            
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="3" data-path="listas/index.html">
            
                
                    <a href="../listas/index.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>3.</b>
                        
                        Listas y correspondencia de patrones
                    </a>
            
            
            <ul class="articles">
                
    
        <li class="chapter " data-level="3.1" data-path="listas/listas.html">
            
                
                    <a href="../listas/listas.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>3.1.</b>
                        
                        Definiendo las listas
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="3.2" data-path="listas/aplicacion.html">
            
                
                    <a href="../listas/aplicacion.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>3.2.</b>
                        
                        Realizando cálculos con listas
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="3.3" data-path="listas/desafio-extra.html">
            
                
                    <a href="../listas/desafio-extra.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>3.3.</b>
                        
                        Desafío extra: aplanar una lista
                    </a>
            
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="4" data-path="alto-orden/index.html">
            
                
                    <a href="../alto-orden/index.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>4.</b>
                        
                        Programación de alto orden y registros
                    </a>
            
            
            <ul class="articles">
                
    
        <li class="chapter " data-level="4.1" data-path="alto-orden/entornos-contextuales.html">
            
                
                    <a href="../alto-orden/entornos-contextuales.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>4.1.</b>
                        
                        Conceptos claves
                    </a>
            
            
        </li>
    
        <li class="chapter active" data-level="4.2" data-path="alto-orden/ejemplos.html">
            
                
                    <a href="../alto-orden/ejemplos.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>4.2.</b>
                        
                        Uniendo los conceptos
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="4.3" data-path="alto-orden/registros.html">
            
                
                    <a href="../alto-orden/registros.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>4.3.</b>
                        
                        Registros
                    </a>
            
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="5" data-path="arboles/index.html">
            
                
                    <a href="../arboles/index.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>5.</b>
                        
                        Árboles y complejidad computacional
                    </a>
            
            
            <ul class="articles">
                
    
        <li class="chapter " data-level="5.1" data-path="arboles/arboles.html">
            
                
                    <a href="../arboles/arboles.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>5.1.</b>
                        
                        Árboles
                    </a>
            
            
        </li>
    

            </ul>
            
        </li>
    


            
            <li class="divider"></li>
            <li>
                <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
                    Published with GitBook
                </a>
            </li>
            
        </ul>
    </nav>
</div>

    <div class="book-body">
        <div class="body-inner">
            <div class="book-header" role="navigation">
    <!-- Actions Left -->
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../" >Introduction</a>
    </h1>
</div>

            <div class="page-wrapper" tabindex="-1" role="main">
                <div class="page-inner">
                
                
                    <section class="normal" id="section-">
                    
                        <h1 id="uniendo-los-conceptos-ejemplos-de-programaci&#xF3;n-de-alto-orden">Uniendo los conceptos: Ejemplos de programaci&#xF3;n de alto orden</h1>
<p>Bien, hemos llegado a una de las lecciones claves del curso: mostrar qu&#xE9; podemos hacer con la programaci&#xF3;n de alto orden. En la lecci&#xF3;n anterior establecimos que en la programaci&#xF3;n funcional los procedimientos son un par compuesto de un <em>procedimiento como valor</em> y un <em>entorno contextual</em>. Esta definici&#xF3;n es enormemente expresiva. De hecho, se podr&#xED;a decir que es <em>la invenci&#xF3;n m&#xE1;s importante</em> en los lenguajes de programaci&#xF3;n, ya que desde que fue inventada en los a&#xF1;os 50 ha hecho posible construir sistemas grandes basados en abstracci&#xF3;n de datos (usando capas, encapsulaci&#xF3;n, etc). Muchas de las buenas propiedades de los lenguajes de programaci&#xF3;n est&#xE1;n basadas en esta idea clave de la programaci&#xF3;n de alto orden, as&#xED; que es sumamente relevante revisar m&#xE1;s de cerca su potencial. Pero antes de revisar algunos ejemplos de uso, primero necesitamos comprender cierto marco te&#xF3;rico, en espec&#xED;fico, ciertas nociones y conceptos habituales en la jerga de la programaci&#xF3;n de alto orden que nos permitir&#xE1;n entendernos mejor cuando se trate de describir las distintas caracter&#xED;sticas que la rodean. Bien, lo primero y m&#xE1;s esencial, es estar al tanto que en la programaci&#xF3;n de alto orden contamos con la capacidad de pasar procedimientos (o funciones) como entradas a otras funciones y, tambi&#xE9;n de retornar procedimientos como salida. Esto, de hecho, es una consecuencia directa de considerar a los procedimientos como valores: tal como podemos pasar y retornar enteros, podemos pasar y retornar funciones. Otra noci&#xF3;n clave es que las funciones tienen <em>un orden</em>. De hecho, nota que estamos hablando de programaci&#xF3;n <em>de alto orden</em>. As&#xED; que, &#xBF;a qu&#xE9; nos referimos con el concepto de <em>orden de una funci&#xF3;n</em>? &#xBF;A qu&#xE9; nos referimos tambi&#xE9;n con la idea de <em>alto orden</em>?. Bueno, b&#xE1;sicamente cuando nos referimos al orden de una funci&#xF3;n lo que buscamos describir es el &#xAB;nivel de profundidad de una funci&#xF3;n en una cadena de funciones&#xBB;, o en otras palabras, cu&#xE1;ntas llamadas dentro de otras funciones se han realizado antes para llegar a la llamada de una funci&#xF3;n en espec&#xED;fico. Por ejemplo, si para llamar a una funci&#xF3;n c() hay que realizar el siguiente camino [dato -&gt; a() -&gt; b() -&gt; c()], entonces podr&#xED;amos decir que c() es una funci&#xF3;n de &#xAB;tercer&#xBB; orden o orden tres. Adicionalmente, tambi&#xE9;n podr&#xED;amos decir que b() es de segundo orden, y a() de primer orden, pues recibe un dato que no es una funci&#xF3;n, y luego tambi&#xE9;n, asumimos que no retorna una funci&#xF3;n, sino un valor que obtiene tras pedir ayuda a b() (donde, a su vez, b() pide ayuda a c()).</p>
<p>A continuaci&#xF3;n, se muestra una definici&#xF3;n un tanto m&#xE1;s compacta de c&#xF3;mo se define el orden de una funci&#xF3;n.</p>
<h4 id="orden-de-una-funci&#xF3;n">Orden de una funci&#xF3;n</h4>
<p>Definimos el orden de una funci&#xF3;n de la siguiente manera:</p>
<ul>
<li><p>Una funci&#xF3;n cuya entrada y salida no son funciones es una funci&#xF3;n de <em>primer orden</em></p>
</li>
<li><p>Una funci&#xF3;n en cuya entrada o salida hay una funci&#xF3;n de orden m&#xE1;ximo <em>N</em> se considera un funci&#xF3;n de <em>orden N + 1</em></p>
</li>
</ul>
<p>Nota que en la medida que vamos aumentando el orden de las funciones (definiendo mayor profundidad), tambi&#xE9;n nos vamos abstrayendo m&#xE1;s y m&#xE1;s de los distintos <em>c&#xF3;mo</em> definidos en el programa. A mayor orden, mayor abstracci&#xF3;n y generalidad.</p>
<p><strong>Nota</strong>: El nombre de programaci&#xF3;n de alto orden viene justamente de la idea de programar utilizando funciones de orden superior a uno.</p>
<h4 id="genericidad">Genericidad</h4>
<p>Bien, ahora que ya tenemos en cuenta estas dos nociones claves de la programaci&#xF3;n de alto orden, vayamos revisando los otros conceptos al mismo tiempo que vemos ejemplos de lo que podemos hacer con la programaci&#xF3;n de alto orden. El primer ejemplo da cuenta del concepto de <em>genericidad</em>. El t&#xE9;rmino genericidad, por lo general, b&#xE1;sicamente se refiere a cuando una funci&#xF3;n se pasa como argumento a otra funci&#xF3;n. Toma como ejemplo el siguiente programa:</p>
<pre><code>fun Map(Funcion, Lista):
  case Lista:
    of nil
      return nil
    elseif E|C
      return Funcion(E)|Map(Funcion, C)
  end
end
</code></pre><p>En este caso, definimos una funci&#xF3;n Map que toma como argumentos a otra funci&#xF3;n y una lista, y que nos deber&#xED;a retornar una nueva lista creada a partir de aplicar la funci&#xF3;n pasada como argumento a cada uno de los elementos de la lista. Si posteriormente ejecutamos esta funci&#xF3;n pasando como argumento una determinada funci&#xF3;n an&#xF3;nima y lista como se muestra a continuaci&#xF3;n:</p>
<pre><code>Map(fun(x) return x*x end , [5, 6, 7])
</code></pre><p>entonces lo que obtenemos es una lista compuesta con el cuadrado de cada uno de los elementos de la lista pasada como segundo argumento (es decir, obtenemos la lista [25, 36, 49]). Ahora, &#xBF;Cu&#xE1;l es el orden de esta funci&#xF3;n Map? Bueno, eso depende de la funci&#xF3;n que reciba como argumento. En este caso, dado que la funci&#xF3;n que recibe es de orden uno, entonces el orden de map es dos.</p>
<h4 id="instanciaci&#xF3;n">Instanciaci&#xF3;n</h4>
<p>Veamos otro ejemplo. En este caso el concepto subyacente es el de <em>instanciaci&#xF3;n</em>. As&#xED; como la <em>genericidad</em> se refer&#xED;a a tomar una funci&#xF3;n como entrada, la <em>instanciaci&#xF3;n</em> se refiere a la otra parte, al retorno de una funci&#xF3;n como salida. El siguiente c&#xF3;digo da muestra de un ejemplo de instanciaci&#xF3;n:</p>
<pre><code>fun hacerSuma(A):
  return fun(x) return x + A end
end

Sumar5 = hacerSuma(5)

Imprimir(Sumar5(100))
</code></pre><p>Definimos una funci&#xF3;n hacerSuma() que toma como argumento un entero, y luego retorna una funci&#xF3;n an&#xF3;nima que incluye en su entorno contextual la correspondencia entre A y el argumento que le hayamos dado a la funci&#xF3;n. Luego, tal como se muestra debajo de la definici&#xF3;n de hacerSuma(), podemos llamar a la funci&#xF3;n con un valor en espec&#xED;fico, como 5, y almacenar la funci&#xF3;n an&#xF3;nima de retorno en una variable. En este caso, la variable est&#xE1; enlazada al identificador Sumar5. Nota adem&#xE1;s que este identificador se puede tratar posteriormente como si se tratara de una funci&#xF3;n (pues, de hecho, es a lo que enlaza), siendo posible usarlo como intermediario para acceder a la funci&#xF3;n an&#xF3;nima que toma un entero y le suma 5 que obtuvimos anteriormente. Luego, el c&#xF3;digo finaliza imprimiendo 105. Bien, en definitiva, esto es la instanciaci&#xF3;n. Si ya conoces algo de orientaci&#xF3;n a objetos puedes haber notado la cercan&#xED;a de esta idea con la relaci&#xF3;n entre las clases y sus instancias. De hecho, como ya veremos, hay una conexi&#xF3;n muy fuerte entre estas ideas. Ahora, repitamos la pregunta que nos hicimos para Map &#xBF;Cu&#xE1;l es el orden de la funci&#xF3;n hacerSuma?. Bueno, dado que retorna una funci&#xF3;n de primer orden, entonces su orden es dos.</p>
<p><strong>Nota</strong>: Como el identificador A dentro de la funci&#xF3;n an&#xF3;nima est&#xE1; declarado afuera de la misma, en particular, al momento de hacer una llamada a la funci&#xF3;n hacerSuma, entonces A es parte del entorno contextual de la funci&#xF3;n an&#xF3;nima. Cada vez que llamamos a hacerSuma, retornamos una nueva versi&#xF3;n de la funci&#xF3;n an&#xF3;nima con A asociado al valor del argumento en espec&#xED;fico que hayamos pasado. Por lo tanto, si bien en Sumar5 se almacena una versi&#xF3;n d&#xF3;nde siempre A = 5, podr&#xED;amos llamar a la funci&#xF3;n con un argumento distinto cada vez que queramos contar con una versi&#xF3;n donde A tenga otro valor.</p>
<h4 id="composici&#xF3;n-de-funciones">Composici&#xF3;n de funciones</h4>
<p>El siguiente concepto ya lo mencionamos antes: la <em>composici&#xF3;n de funciones</em>. Aunque ahora lo vemos m&#xE1;s bien desde su definici&#xF3;n matem&#xE1;tica, en lugar de simplemente como la capacidad de llamar a una funci&#xF3;n dentro de otra. En matem&#xE1;ticas, cuando se habla de componer una funci&#xF3;n, se hace referencia a lo siguiente:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>(</mo><mi>b</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">
a(b(x))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit">a</span><span class="mopen">(</span><span class="mord mathit">b</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p>
<p>Es decir, a la inclusi&#xF3;n de una funci&#xF3;n como par&#xE1;metro de otra, con el fin de obtener otra funci&#xF3;n completamente distinta. As&#xED;, por ejemplo, si <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">a = x^2 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mrel">=</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span></span></span></span> y <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>=</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">b = x + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">b</span><span class="mrel">=</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span>, entonces mediante la composici&#xF3;n de <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span></span></span></span> y <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">b</span></span></span></span> obtendr&#xED;amos <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>(</mo><mi>b</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo><mo>=</mo><mo>(</mo><mi>x</mi><mo>+</mo><mn>1</mn><msup><mo>)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">a(b(x)) = (x + 1)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mopen">(</span><span class="mord mathit">b</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span><span class="mclose">)</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose"><span class="mclose">)</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span></span></span></span>. En programaci&#xF3;n de alto orden, dado que podemos pasar funciones como argumentos y tambi&#xE9;n retornar funciones, componer funciones como en la matem&#xE1;ticas resulta natural. Podr&#xED;amos, de hecho, definir una funci&#xF3;n que tome otras dos funciones y retorne la composici&#xF3;n entre ellas:</p>
<pre><code>fun Composicion(Funcion1, Funcion2):
  return fun(X): Funcion1(Funcion2(X))
end
</code></pre><p>B&#xE1;sicamente, retornamos una funci&#xF3;n an&#xF3;nima que toma un argumento X y retorna el resultado de evaluar el retorno Funcion2(X) con Funcion1. Por ejemplo, podr&#xED;amos obtener la funci&#xF3;n <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mn>1</mn><msup><mo>)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">(x + 1)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose"><span class="mclose">)</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span></span></span></span>, tal como la obtenemos mediante composici&#xF3;n matem&#xE1;tica:</p>
<pre><code>cuadratica = Composicion(fun(X) return x*x end, fun(X) return x + 1 end)

cuadratica(3) //=&gt; (3 + 1)^2 = 16
</code></pre><p>En este caso, pasamos las funciones que deseamos componer como funciones an&#xF3;nimas. Ahora, nota que las funciones usadas en la funci&#xF3;n an&#xF3;nima retornada se declaran afuera de esta funci&#xF3;n, y por lo tanto, son parte del entorno contextual de la funci&#xF3;n que se retorna. El argumento X, en cambio, se puede especificar cada vez que llamemos a la funci&#xF3;n retornada.</p>
<p><strong>Ejercicio</strong> <br>
&#xBF;Qu&#xE9; sucede si se realiza la composici&#xF3;n Composicion(cuadratica, cuadratica) y a la funci&#xF3;n retornada se le pasa c&#xF3;mo argumento el valor 3?</p>
<h4 id="abstracci&#xF3;n-de-un-acumulador">Abstracci&#xF3;n de un acumulador</h4>
<p>Bien, ahora revisemos otro concepto: la <em>abstracci&#xF3;n de un acumulador</em>. Resulta que cuando se programa en estilo funcional, debido a que las variables son de asignaci&#xF3;n &#xFA;nica, suele estar la preocupaci&#xF3;n de que uno vaya a necesitar muchas, muchas variables, y que debido a eso, se arme un completo desorden en tu programa. Sin embargo, esta preocupaci&#xF3;n es completamente infundada. Una opci&#xF3;n para evitar esto, es ocultar un acumulador usando programaci&#xF3;n de alto orden. Y justamente de eso se trata cuando hablamos de <em>abstraernos de un acumulador</em>. Considera el siguiente ejemplo, digamos que queremos sumar los elementos de una lista. Contamos con una lista <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo>=</mo><mo>[</mo><msub><mi>a</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>&#x2026;</mo><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>&#x2212;</mo><mn>1</mn></mrow></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">L = [a_0, a_1, a_2, \ldots, a_{n-1}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">L</span><span class="mrel">=</span><span class="mopen">[</span><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span><span class="mpunct">,</span><span class="minner">&#x2026;</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">n</span><span class="mbin">&#x2212;</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span><span class="mclose">]</span></span></span></span> y queremos obtener <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><mo>+</mo><mo>&#x2026;</mo><mo>+</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>&#x2212;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">S = a_0 + a_1 + a_2 + \ldots + a_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mrel">=</span><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span><span class="mbin">+</span><span class="minner">&#x2026;</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">n</span><span class="mbin">&#x2212;</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span></span></span></span>. Nota que como empezamos la numeraci&#xF3;n desde 0, el n-&#xE9;simo elemento tiene sub&#xED;ndice <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&#x2212;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mbin">&#x2212;</span><span class="mord mathrm">1</span></span></span></span>. Bueno, resulta que esta operaci&#xF3;n la podemos escribir de forma asociativa de la siguiente manera:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mo>(</mo><mo>&#x2026;</mo><mo>(</mo><mo>(</mo><mo>(</mo><mn>0</mn><mo>+</mo><msub><mi>a</mi><mn>0</mn></msub><mo>)</mo><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mo>)</mo><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><mo>)</mo><mo>+</mo><mo>&#x2026;</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>&#x2212;</mo><mn>1</mn></mrow></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">
S = (\ldots (((0 + a_0) + a_1) + a_2) + \ldots a_{n - 1})
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mrel">=</span><span class="mopen">(</span><span class="minner">&#x2026;</span><span class="mopen">(</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathrm">0</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span><span class="mclose">)</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span><span class="mclose">)</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span><span class="mclose">)</span><span class="mbin">+</span><span class="minner">&#x2026;</span><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">n</span><span class="mbin">&#x2212;</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>Primeros sumamos a 0 el primer elemento de la lista, luego a ese resultado le sumamos el segundo elemento, y luego a ese resultado le sumamos el tercero, y as&#xED; en adelante, hasta sumar todos elementos. En otras palabras, asumiendo la existencia de una funci&#xF3;n F que retorna la suma de dos elementos, podr&#xED;amos reemplazar cada una de las sumas presentes en la f&#xF3;rmula anterior con una llamada a esta funci&#xF3;n F. Realizando ello la suma total se podr&#xED;a ver tambi&#xE9;n c&#xF3;mo una composici&#xF3;n de funciones F una sobre otra. De modo que podr&#xED;amos escribir <em>gen&#xE9;ricamente</em> esta suma de la siguiente manera:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mi>F</mi><mo>(</mo><mi>F</mi><mo>(</mo><mo>&#x2026;</mo><mi>F</mi><mo>(</mo><mi>F</mi><mo>(</mo><mi>F</mi><mo>(</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>a</mi><mn>0</mn></msub><mo>)</mo><mo separator="true">,</mo><msub><mi>a</mi><mn>1</mn></msub><mo>)</mo><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo>)</mo><mo>)</mo><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>&#x2212;</mo><mn>1</mn></mrow></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">
S = F(F(\ldots F(F(F(0, a_0), a_1), a_2)), a_{n-1})
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="minner">&#x2026;</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">n</span><span class="mbin">&#x2212;</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>Y decimos <em>gen&#xE9;ricamente</em>, ya que si bien para que lo anterior retorne la suma de los elementos de la lista, F debe retornar la suma de sus dos argumentos, F no necesariamente se tiene que limitar a esta definici&#xF3;n. F podr&#xED;a ser una funci&#xF3;n cualquiera, y de ser eso posible, podr&#xED;amos utilizar la perspectiva anterior para resolver mucho m&#xE1;s que la suma de los elementos de una lista. Si F retornara el producto de sus argumentos, podr&#xED;amos obtener la productoria de los elementos de la lista (si el primer argumento inicial fuera 1, claro). O si F retornara el m&#xE1;ximo entre dos elementos, podr&#xED;amos obtener el m&#xE1;ximo de una lista de elementos. Se entiende la idea. Bien, ahora para solucionar este problema desde esta perspectiva, podemos definir una funci&#xF3;n que haga justamente lo que muestra la expresi&#xF3;n de m&#xE1;s arriba. Una funci&#xF3;n que tome como argumentos, una lista, una funci&#xF3;n, y un elemento inicial, y realice toda esa serie de composiciones, para luego retornar el resultado buscado. Llamemos a esta funci&#xF3;n <code>AsociatividadIzq</code>, ya que la asociatividad se va realizando justamente desde esa direcci&#xF3;n.</p>
<pre><code>S = AsociatividadIzq(Lista, Funcion, i)
</code></pre><p>Ahora, si pasamos a AsociatividadIzq como segundo argumento una funci&#xF3;n que retorne la suma de dos n&#xFA;meros, y pasamos como tercer argumento el valor 0, entonces obtenemos la suma de todos los elementos de cu&#xE1;l sea la lista que se pase como primer argumento. Finalmente, nota como mediante la composici&#xF3;n de funciones evitamos completamente el uso de un acumulador. El acumulador est&#xE1; oculto dentro de la definici&#xF3;n de AsociatividadIzq.</p>
<p>A continuaci&#xF3;n se muestra una definici&#xF3;n para nuestra funci&#xF3;n AsociatividadIzq:</p>
<pre><code>fun AsociatividadIzq(Lista, Funcion, A): //A = acumulador
  case L:
    of nil
      return A
    elseif E|C
      return AsociatividadIzq(C, Funcion, Funcion(A, E))
  end
end
</code></pre><p>Toma como argumentos una lista, una funci&#xF3;n, y el valor inicial que queremos para el acumulador. Luego realiza un <code>case</code> con el fin de verificar si la lista est&#xE1; vac&#xED;a o tiene al menos un elemento. Si est&#xE1; vac&#xED;a, entonces retorna el acumulador. Si tiene al menos un elemento, entonces realiza una llamada recursiva pasando la cola de la lista como primer argumento (o sea una versi&#xF3;n reducida de la lista original), la funci&#xF3;n pasada como entrada sin ninguna modificaci&#xF3;n como segundo argumento y finalmente el resultado de aplicar la funci&#xF3;n de entrada al acumulador y el encabezado como &#xFA;ltimo argumento. Ya con esta definici&#xF3;n, podemos solucionar como caso particular el problema de sumar los elementos de una lista que planteamos al inicio:</p>
<pre><code>S = AsociatividadIzq(Lista, fun(x, y) return x + y end, 0)
</code></pre><h4 id="encapsulaci&#xF3;n">Encapsulaci&#xF3;n</h4>
<p>Aunque ya hemos visto varios conceptos y ejemplos asociados a esos conceptos, a&#xFA;n no hemos agotado para nada las habilidades de la programaci&#xF3;n de alto orden. El siguiente concepto que vamos a revisar es la <em>encapsulaci&#xF3;n</em>. Con encapsulaci&#xF3;n nos referimos a una cosa bastante interesante que podemos hacer: ocultar un valor dentro de una funci&#xF3;n. Considera el siguiente ejemplo:</p>
<pre><code>fun Cero():
  return 0
end

fun Inc(H):
  declare N = H() + 1
  return fun() return N end
end
</code></pre><p>Definimos dos funciones, una llamada Cero y otra Inc. La funci&#xF3;n Cero es sencilla, no toma ning&#xFA;n argumento y retorna el valor 0. Inc, en cambio, toma una funci&#xF3;n como argumento, y luego declara un identificador N al que asocia la suma de llamar a la funci&#xF3;n del argumento y sumarle 1. Finalmente, Inc retorna una funci&#xF3;n an&#xF3;nima que no toma argumentos y devuelve el valor de N oculto en su entorno contextual. Ahora, si por ejemplo, anidamos llamadas a Inc como se muestra a continuaci&#xF3;n:</p>
<pre><code>Tres = Inc(Inc(Inc(Cero)))

Imprimir(Tres()) //=&gt; 3
</code></pre><p>Entonces obtenemos un efecto curioso. Con la llamada m&#xE1;s interna de Inc, la que tiene como argumento la funci&#xF3;n Cero, obtenemos una funci&#xF3;n an&#xF3;nima cuyo valor de N en su entorno contextual es 1. Luego, con la siguiente llamada de Inc a la que pasamos la funci&#xF3;n an&#xF3;nima obtenida anteriormente, obtenemos otra funci&#xF3;n an&#xF3;nima, pero esta vez una cuyo valor de N est&#xE1; asociado a 2. En la &#xFA;ltima llamada el efecto se repite, y obtenemos una funci&#xF3;n an&#xF3;nima con N igual a 3 en su entorno contextual, que es la funci&#xF3;n que almacenamos en Tres. Cuando despu&#xE9;s imprimimos el valor que se obtiene al llamar a tres, podemos observar como efectivamente este n&#xFA;mero es 3. Este ejemplo es algo trivial, pero nos muestra como las funciones pueden ocultar cosas dentro de ellas, o m&#xE1;s especificamente, valores dentro de su entorno contextual y c&#xF3;mo podemos hacer uso de estos valores ocultos. Esto, de hecho, es la base de la encapsulaci&#xF3;n. Y aunque es un ejemplo trivial, como ya dijimos, se volver&#xE1; muy importante m&#xE1;s adelante cuando lo combinemos con otras t&#xE9;cnicas y lo usemos en abstracci&#xF3;n de datos.</p>
<p><strong>A tener en cuenta</strong>: <br>
&#xBF;Qu&#xE9; pasar&#xED;a si en la definici&#xF3;n de Inc, en lugar de declarar una variable N que almacene H() + 1 fuera de la funci&#xF3;n an&#xF3;nima, se retornara directamente una funci&#xF3;n con esta suma? Es decir, &#xBF;Qu&#xE9; pasar&#xED;a si la definici&#xF3;n de Inc fuera la siguiente?</p>
<pre><code>Inc(H):
  return fun() return H() + 1 end
end
</code></pre><p>&#xBF;Cu&#xE1;l es la diferencia entre las dos funciones?&#xBF;Qu&#xE9; almacenar&#xED;a ahora el identificador Tres?</p>
<h4 id="ejecuci&#xF3;n-retardada">Ejecuci&#xF3;n retardada</h4>
<p>El siguiente concepto tambi&#xE9;n es bastante poderoso. Resulta que usando programaci&#xF3;n de alto orden podemos definir nuestras propias estructuras de control. En espec&#xED;fico, podemos definir funciones que tomen a otras funciones como argumentos, como ya nos es com&#xFA;n, pero que tengan la particularidad de &#xAB;decidir&#xBB; si ejecutar o no esa funci&#xF3;n. Y esto es lo que se conoce como <em>ejecuci&#xF3;n retardada</em>. Ahora, &#xBF;C&#xF3;mo se supone que la funci&#xF3;n &#xAB;toma una decisi&#xF3;n&#xBB;?. El mecanismo es bastante simple. Es el mismo que hemos venido usando en todos nuestros programas anteriores, evaluar una condici&#xF3;n usando una instrucci&#xF3;n if. Sin embargo, la diferencia est&#xE1; en que la condici&#xF3;n es la llamada a una funci&#xF3;n que retorna un valor de verdad, tal como se muestra a continuaci&#xF3;n:</p>
<pre><code>proc IsTrue(Condicion, Funcion):
  if Condicion():
    Funcion()
  end
end
</code></pre><p>Nota que para este ejemplo, tanto Condicion como Funcion deben ser funciones que no tomen ning&#xFA;n argumento. Adem&#xE1;s, por supuesto, que Condicion debe retornar un booleano. Respecto al funcionamiento, IsTrue simplemente se limita a tomar las dos funciones, y luego tras ejecutar a Condicion, &#xAB;decide&#xBB; si ejecutar o no a Funcion. Bien, el comportamiento que podemos obtener con la funci&#xF3;n anterior es bastante interesante, veamos un ejemplo. Supongamos que llamamos a la funci&#xF3;n de la siguiente manera:</p>
<pre><code>AlgunaFuncion = fun() Imprimir(1000) end
AlgunaCondicion = fun() return 1 &lt; 2 end

IsTrue(AlgunaCondicion, AlgunaFuncion)
</code></pre><p>En este caso, definimos dos funciones an&#xF3;nimas que vinculamos a los identificadores AlgunaFuncion y AlgunaCondicion. Luego llamamos a IsTrue haciendo uso de estas funciones. El resultado, como podr&#xE1;s pensar, es la impresi&#xF3;n de 1000. Esto debido a que AlgunaCondicion siempre retornar&#xE1; true. Ahora bien, lo que vale la pena notar, es que dentro de la funci&#xF3;n se eval&#xFA;a una condici&#xF3;n que pasamos desde fuera. Y con ello, hacemos una completa diferenciaci&#xF3;n entre declarar una funci&#xF3;n y determinar si ejecutarla o no. Esta separaci&#xF3;n entre definici&#xF3;n y condici&#xF3;n resulta bastante &#xFA;til, pues como afirmamos al principio, incluso se puede usar para construir estructuras de control, como instrucciones if, while, for, completamente desde cero. Aunque, claro, no necesitas porque inventar estas estructuras por ti mismo en un lenguaje que ya las proporciona, pero usando programaci&#xF3;n de alto orden, puedes a&#xF1;adir tus propias estructuras de control sofisticadas.</p>
<h3 id="resumen">Resumen</h3>
<p>Bien, a&#xFA;n quedan muchas cosas m&#xE1;s que se pueden hacer con programaci&#xF3;n de alto orden. Pero los seis ejemplos y los conceptos asociados que hemos visto hasta ahora, ilustran bastante bien su potencial y expresividad. En siguientes secciones iremos mostrando a&#xFA;n m&#xE1;s ejemplos de la fuerza que rodea a esta idea. En especifico, cuando comencemos a hablar de abstracci&#xF3;n de datos en detalle, usaremos estas t&#xE9;cnicas junto a otras, y mostraremos como la abstracci&#xF3;n de datos est&#xE1; construida sobre la programaci&#xF3;n de alto orden.</p>
<h4 id="conceptos-y-ejemplos-de-uso-de-la-programaci&#xF3;n-de-alto-orden">Conceptos y ejemplos de uso de la programaci&#xF3;n de alto orden</h4>
<ul>
<li>Genericidad</li>
<li>Instanciaci&#xF3;n</li>
<li>Composici&#xF3;n de funciones</li>
<li>Abstracci&#xF3;n de un acumulador</li>
<li>Encapsulaci&#xF3;n</li>
<li>Ejecuci&#xF3;n retardada</li>
</ul>
<p><strong>Ejercicio</strong>: <br>
El siguiente ejercicio se centra en el uso de funciones que toman funciones como entrada.</p>
<p>Considera la siguiente funci&#xF3;n:</p>
<pre><code>fun FunnyFunc(ListaFunciones, Lista):
  case Lista:
    of E|C
      return ListaFunciones.head(E)|FunnyFunc(ListaFunciones.cola C)
    else
      return nil
  end
end
</code></pre><p>ListaFunciones es una lista de funciones que toman un entero como entrada y Lista es una lista de enteros. Estas dos listas DEBEN tener el mismo tama&#xF1;o y su tama&#xF1;o tiene que ser estrictamente mayor a 1.</p>
<p>Se te pide llamar al siguiente procedimiento de prueba:</p>
<pre><code>proc Prueba(ListaFunciones, Lista, ListaSolucion):
  Imprimir(FunnyFunc(ListaFunciones, Lista) == ListaSolucion)
end
</code></pre><p>Junto a ello, se te pide crear un cierto n&#xFA;mero de funciones y llamar al procedimiento de prueba con una lista que contenga a estas funciones, una lista de enteros de tu elecci&#xF3;n y la lista que se espera como resultado.</p>
<p>M&#xE1;s precisamente, si Fun1, Fun2, ..., FunN son las funciones que creaste y que colocas en ListaFuniones. Y si Int1, Int2, ..., IntN es la lista de n&#xFA;meros de tu elecci&#xF3;n que corresponde a Lista, y Sol1, Sol2, ..., SolN son los resultado esperados puestos en ListaSolucion, tienes que hacer la siguiente llamada:</p>
<pre><code>Prueba(ListaFunciones, Lista, ListaSolucion)
</code></pre><p><strong>Ejercicio</strong>: <br></p>
<p>Este ejercicio se centra en el uso de las funciones como salida.</p>
<p>Tu profesor de matem&#xE1;ticas te pide que le escribas una funci&#xF3;n. Te da el dominio y codominio de su funci&#xF3;n matem&#xE1;tica y tu funci&#xF3;n tiene que producir otra funci&#xF3;n que represente a la funci&#xF3;n matem&#xE1;tica de tu profesor.</p>
<p>Tanto el dominio como el codominio son listas de n&#xFA;meros de la misma longitud. La funci&#xF3;n que retornes deber&#xED;a recibir como argumento un valor del dominio y retornar el valor que le corresponde del codominio. En espec&#xED;fico, a cada i-&#xE9;simo elemento del dominio, le debe corresponder el i-&#xE9;simo elemento del codominio. Es decir f(D[i]) == C[i]. Adicionalmente, si el valor pasado como argumento no se encuentra en el dominio, la funci&#xF3;n deber&#xED;a devolver la cadena &quot;No encontrado&quot;.</p>
<p><strong>Para tomar en cuenta</strong>: <br></p>
<p>&#xBF;C&#xF3;mo usar&#xED;as la programaci&#xF3;n de alto orden en la pr&#xE1;ctica?&#xBF;Qu&#xE9; ejemplos se te ocurren?</p>

                    
                    </section>
                
                
                </div>
            </div>
        </div>

        
        <a href="../alto-orden/entornos-contextuales.html" class="navigation navigation-prev " aria-label="Previous page: Conceptos claves"><i class="fa fa-angle-left"></i></a>
        
        
        <a href="../alto-orden/registros.html" class="navigation navigation-next " aria-label="Next page: Registros"><i class="fa fa-angle-right"></i></a>
        
    </div>
</div>

        
<script src="../gitbook/app.js"></script>

    
    <script src="../gitbook/plugins/gitbook-plugin-search/lunr.min.js"></script>
    

    
    <script src="../gitbook/plugins/gitbook-plugin-search/search.js"></script>
    

    
    <script src="../gitbook/plugins/gitbook-plugin-sharing/buttons.js"></script>
    

    
    <script src="../gitbook/plugins/gitbook-plugin-fontsettings/buttons.js"></script>
    

<script>
require(["gitbook"], function(gitbook) {
    var config = {"katex":{},"highlight":{},"search":{"maxIndexSize":1000000},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2}};
    gitbook.start(config);
});
</script>

        
    </body>
    
</html>
